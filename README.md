 <h1 align="center">📚 Golang一站式学习仓库</h1>
 <p align="center">
  🌟 本仓库旨在为学习 Golang 的程序员们提供学习资源导航
</p>
 <p align="center">
  💡 涵盖从基础知识到实战项目的资料与示例，帮助你快速入门并逐步进阶！
</p>

---

## 📌 目录

* [简介](#-简介)
* [仓库目标](#-仓库一览)
* [学习资料](#-学习资料)
  * [官方资料](#-官方资料)
  * [精选书籍](#-精选书籍)
  * [入门教程](#-入门教程)
  * [进阶技术](#-进阶技术)
  * [技术文章](#-技术文章)
  * [学习视频](#-学习视频)
  * [面试题](#-面试题)
* [相关技术](#-相关技术)
  * [网络基础](#-网络基础)
  * [MySQL](#-MySQL)
  * [Redis](#-Redis)
* [Gin框架](#-Gin框架)
* [项目实战](#-项目实战)
---

## 🚀 简介
Golang（又称 Go）是由Google于 2009 年推出的静态强类型、编译型编程语言，核心设计目标是解决 “大规模系统开发中的效率、并发、部署复杂度” 问题，兼顾了 C 语言的性能与 Python 的开发便捷性，目前已成为云原生、后端服务、工具开发领域的主流语言之一。

---

## 🔍 仓库一览

* 提供 基础知识 + 工具框架 + 实战项目 的学习参考

* 收录 学习资料、书籍、开源项目，避免信息碎片化

---

## 📚 学习资料
### 🍀 官方资料
**Go官方文档**：[https://go.dev/ref/spec](https://go.dev/ref/spec)

**Go语言中文网**：[https://go.p2hp.com/](https://go.p2hp.com/)

**Go编程最佳实践**：[https://go.dev/doc/effective_go](https://go.dev/doc/effective_go) 

**Go谷歌开源仓库**：[https://cs.opensource.google/go](https://cs.opensource.google/go)

**Go语言GitHub仓库**：[https://github.com/golang/go](https://github.com/golang/go)

---
### 📖 精选书籍
#### 入门阶段
| No. | title | author |
| :--- | :--- | :--- |
| 1 | Go 语言圣经 | Alan A. A. Donovan、Brian W. Kernighan |
| 2 | Go 入门指南 | Caleb Doxsey |

#### 进阶阶段
| No. | title | author |
| :--- | :--- | :--- |
| 1 | Effective Go | Go 官方团队 |
| 2 | Go Web 编程 | 谢孟军 |
| 3 | Go 语言高性能编程 | 极客时间 |

#### 深入阶段
| No. | title | author |
| :--- | :--- | :--- |
| 1 | Go 语言设计与实现 | draveness |
| 2 | Go 高级编程 | 柴树杉、曹春晖 |
| 3 | Go 语言设计哲学 | 陈皓 |

---
### 📝 入门教程
| No. | address |
| :--- | :--- |
| 1 | [官方教程](https://tour.go-zh.org/welcome/1) |
| 2 | [菜鸟教程](https://www.runoob.com/go/go-tutorial.html) |
| 3 | [C语言中文网](https://c.biancheng.net/golang/syntax/) |
| 4 | [Go语言圣经](https://gopl-zh.github.io/ch1/ch1-01.html) |
| 5 | [Golang中文学习文档](https://golang.halfiisland.com/essential/base/1.grammer.html) |

#### 语法基础
| No. | address |
| :--- | :--- |
| 1 | [基本语法](https://golang.halfiisland.com/essential/base/1.grammer.html) |
| 2 | [数据类型](https://golang.halfiisland.com/essential/base/10.datatype.html) |
| 3 | [常量](https://golang.halfiisland.com/essential/base/30.constant.html) |
| 4 | [变量](https://golang.halfiisland.com/essential/base/40.variable.html) |
| 5 | [输入输出](https://golang.halfiisland.com/essential/base/45.inout.html) |
| 6 | [条件控制](https://golang.halfiisland.com/essential/base/52.condition.html) |
| 7 | [循环控制](https://golang.halfiisland.com/essential/base/55.loop.html) |
| 8 | [切片](https://golang.halfiisland.com/essential/base/60.slice.html) |
| 9 | [字符串](https://golang.halfiisland.com/essential/base/62.string.html) |
| 10 | [映射表](https://golang.halfiisland.com/essential/base/65.map.html) |
| 11 | [指针](https://golang.halfiisland.com/essential/base/67.pointer.html) |
| 12 | [函数](https://golang.halfiisland.com/essential/base/69.func.html) |
| 13 | [结构体](https://golang.halfiisland.com/essential/base/75.struct.html) |
| 14 | [方法](https://golang.halfiisland.com/essential/base/80.method.html) |


---
### ⚙️ 进阶技术
| No. | address |
| :--- | :--- |
| 1 | [接口](https://golang.halfiisland.com/essential/senior/85.interface.html) |
| 2 | [泛型](https://golang.halfiisland.com/essential/senior/90.generic.html) |
| 3 | [迭代器](https://golang.halfiisland.com/essential/senior/91.iterator.html) |
| 4 | [类型](https://golang.halfiisland.com/essential/senior/92.types.html) |
| 5 | [错误](https://golang.halfiisland.com/essential/senior/95.error.html) |
| 6 | [文件](https://golang.halfiisland.com/essential/senior/100.io.html) |
| 7 | [反射](https://golang.halfiisland.com/essential/senior/105.reflect.html) |
| 8 | [并发](https://golang.halfiisland.com/essential/senior/110.concurrency.html) |
| 9 | [模块](https://golang.halfiisland.com/essential/senior/115.module.html) |
| 10 | [测试](https://golang.halfiisland.com/essential/senior/120.test.html) |

---
### 📊 技术文章
| No. | article |
| :--- | :--- |
| 1 | [下载和安装Go](https://go.p2hp.com/doc/install) |
| 2 | [创建一个 Go 模块](https://go.p2hp.com/go.dev/doc/tutorial/create-module) |
| 3 | [多模块工作区入门](https://go.p2hp.com/go.dev/doc/tutorial/workspaces) |
| 4 | [使用 Go 和 Gin 开发 RESTful API](https://go.p2hp.com/go.dev/doc/tutorial/web-service-gin) |
| 5 | [泛型入门](https://go.p2hp.com/go.dev/doc/tutorial/generics) |
| 6 | [模糊测试](https://go.p2hp.com/go.dev/doc/tutorial/fuzz) |
| 7 | [编写 Web 应用程序](https://go.p2hp.com/doc/articles/wiki/) |
| 8 | [管理依赖项](https://go.p2hp.com/doc/modules/managing-dependencies) |
| 9 | [访问关系数据库](https://go.p2hp.com/doc/tutorial/database-access) |
| 10 | [编辑器插件和 IDE](https://go.p2hp.com/go.dev/doc/editors) |
| 11 | [Go语言中使用sqlx来操作事务](https://cloud.tencent.com/developer/article/2444802?policyId=1004) |
| 12 | [Golang学习笔记之Golang与Mysql交互](https://cloud.tencent.com/developer/article/1379871?policyId=1004) |
| 13 | [手把手带你从0搭建一个Golang ORM框架（全）！](https://cloud.tencent.com/developer/article/1927194?policyId=1004) |
| 14 | [golang源码分析（2）：Golang context 包](https://cloud.tencent.com/developer/article/2064586) |
| 15 | [Golang可能会踩的58个坑](https://blog.csdn.net/qq_35461287/article/details/124861875?ops_request_misc=&request_id=&biz_id=102&utm_term=Golang&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-124861875.142^v102^control&spm=1018.2226.3001.4187) |
| 16 | [golang硬核技术（一）内存管理](https://blog.csdn.net/qq_25490573/article/details/130027162?ops_request_misc=&request_id=&biz_id=102&utm_term=golang&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-130027162.142^v102^control&spm=1018.2226.3001.4187) |
| 17 | [golang 定时任务处理](https://blog.csdn.net/molaifeng/article/details/123886894?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b28a2f290521b49e6d14dddd80987be8%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=b28a2f290521b49e6d14dddd80987be8&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-123886894-null-null.142^v102^control&utm_term=golang&spm=1018.2226.3001.4187) |
| 18 | [golang高级进阶（一）：进程、线程、并发、并行、goroutine协程](https://blog.csdn.net/genziisme/article/details/124324755?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-124324755-blog-145618546.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-124324755-blog-145618546.235%5Ev43%5Epc_blog_bottom_relevance_base5&utm_relevant_index=6) |
| 19 | [白话 Golang 协程池](https://cloud.tencent.com/developer/article/1825581) |
| 20 | [全文图解Golang 调度器 GMP 原理与调度](https://zhuanlan.zhihu.com/p/288017699) |
| 21 | [深入理解Go语言中的Channel与Select](https://blog.csdn.net/weixin_53623989/article/details/136209823) |
| 22 | [同步原语与锁](https://draven.co/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/) |







### 📺 学习视频
| No. | address |
| :--- | :--- |
| 1 | []() |
| 2 | []() |
| 3 | []() |
| 4 | []() |

---
### 👥 面试题
[1. golang 中 make 和 new 的区别？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_1)  
[2. 数组和切片（slice）的区别是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_2)  
[3. defer 关键字的作用、执行顺序及对返回值的影响是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_3)  
[4. 字符串拼接的方式有哪些？哪种效率最高？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_4)  
[5. rune 类型的作用是什么？与 byte 的区别是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_5)
[6. 反射（reflection）是什么？如何使用反射获取类型信息和修改变量值？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_6)  
[7. Go 语言中 struct tag 的作用是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_7)  
[8. 说说 Go 中的 init 函数，和它的执行顺序](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_8)  
[9. Map 的底层实现、并发安全性及扩容机制是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_9)  
[10. 如何判断 Map 中是否包含某个键？如何实现有序 Map？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_10)  
[11. golang 哪些类型可以作为 map key？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_11)  
[12. golang 规范中，哪些数据类型不可以比较？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_12)  
[13. slice 的底层结构是怎样的？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_13)  
[14. slice 是怎么扩容的？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_14)  
[15. Goroutine 是什么？与线程的区别是什么？如何创建 Goroutine？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_15)  
[16. golang 的进程、线程、协程的区别](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_16)  
[17. Channel 的作用、底层结构及线程安全性如何？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_17)  
[18. 无缓冲 Channel 和带缓冲 Channel 的区别是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_18)  
[19. GMP 调度模型的核心组件及调度流程是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_19)  
[20. 如何控制 Goroutine 的并发数量？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_20)  
[21. Golang 的垃圾回收（GC）机制及演进过程是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_21)  
[22. 什么是内存逃逸？哪些情况会导致内存逃逸？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_22)  
[23. Go 是如何分配内存的？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_23)  
[24. 什么是内存泄漏？Golang 中常见的内存泄漏场景及排查方式是什么？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_24)  
[25. 如何使用 context 包进行 Goroutine 间的上下文管理？](https://github.com/qiye7c/awesome_golang_learning/blob/main/interview_question/README.md#subject_25)  

---
## 🛠️ 相关技术

# 🐬 MySQL

## 使用Go语言连接MySQL

### 一、安装MySQL驱动    

1.1 安装 MySQL  
首先，确保你的系统中安装了 MySQL 数据库。可以从官网下载安装包进行安装，或者使用包管理器进行安装。  

1.2 安装 Go MySQL 驱动  
在 Go 中，最常用的 MySQL 驱动是 go-sql-driver/mysql。在终端运行以下命令进行安装：
```bash
go get -u github.com/go-sql-driver/mysql
```
1.3 配置数据库连接信息  
在开始编码之前，需要在 MySQL 中创建一个新的数据库和用户，并授予相应的权限。同时，记录下数据库的主机名、端口号、用户名和密码，这些信息将在后续的代码中用于建立连接。

---

### 二、连接MySQL  

在 Go 中，使用 database/sql 包来管理数据库连接。以下是一个简单的示例，展示如何建立连接：

```go
import (
    "database/sql"
    _ "github.com/go-sql-driver/mysql"
)

dsn := "user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=true&loc=Local"
db, err := sql.Open("mysql", dsn)
if err != nil {
    panic(err)
}
defer db.Close()

// 验证连接
err = db.Ping()
if err != nil {
    panic(err)
}
```
---
### 三、增删改查

一旦连接建立，就可以执行 SQL了： 

3.1 创建表：  
```go
_, err := db.Exec(`
CREATE TABLE IF NOT EXISTS users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    age INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
`)
```
3.2 插入数据：
```go
res, err := db.Exec("INSERT INTO users(name, age) VALUES (?, ?)", "Alice", 20)
lastID, _ := res.LastInsertId()  // 获取插入ID
```
3.3 查询数据：
```go
rows, err := db.Query("SELECT id, name, age FROM users WHERE age > ?", 18)
defer rows.Close()

for rows.Next() {
    var id int64
    var name string
    var age int
    rows.Scan(&id, &name, &age)
    fmt.Printf("ID: %d, Name: %s, Age: %d\n", id, name, age)
}
```
3.4 删除数据：
```go
res, err := db.Exec("DELETE FROM users WHERE name=?", "Alice")
rowsAffected, _ := res.RowsAffected()
```
---
### 四、事务处理

在处理涉及多个数据库操作的业务逻辑时，事务是保证数据一致性的关键。以下是一个简单的事务处理示例：  

```go
tx, err := db.Begin()
if err != nil {
    panic(err)
}

_, err = tx.Exec("INSERT INTO users(name, age) VALUES (?, ?)", "Bob", 25)
if err != nil {
    tx.Rollback()
    panic(err)
}

err = tx.Commit()
if err != nil {
    panic(err)
}
```
---
### 五、连接池的使用

5.1 连接池的重要性：  
在高并发的场景下，建立和关闭数据库连接的开销是非常大的。使用连接池可以复用数据库连接，提高性能。  

5.2 连接池配置：
```go
db.SetMaxOpenConns(100)           // 最大打开连接数
db.SetMaxIdleConns(20)            // 最大空闲连接数
db.SetConnMaxLifetime(time.Hour)  // 连接最大存活时间
db.SetConnMaxIdleTime(30*time.Minute) // 连接最大空闲时间
```
---

## GORM的使用   
作为 Go 语言中最受欢迎的对象关系映射（ORM）库，GORM 提供了一套简洁且功能强大的 API，极大地简化了数据库操作。  

### 一、GORM 简介
GORM 是用 Go 语言编写的 ORM 库，它基于 httprouter 和 Go 标准库构建。其主要特点包括：  
- 简洁易用：通过定义结构体来映射数据库表，简化数据操作；
- 功能全面：支持 CRUD、事务、预加载、关联关系、自动迁移等常见功能；
- 扩展性强：内置钩子函数、插件机制以及对多种数据库（MySQL、PostgreSQL、SQLite、SQL Server 等）的支持；
- 性能优秀：经过大量优化，能够在高并发场景下保持稳定性能。

参考:[GORM官方文档](https://gorm.io/zh_CN/docs/index.html)  

---
### 二、环境搭建与安装
在使用 GORM 之前，首先需要安装 Go 环境，然后通过 ```go get``` 命令安装 GORM 及所需数据库驱动。例如，如果你使用 MySQL 数据库，在终端运行以下命令安装：
```bash
# 安装 GORM 框架
go get -u gorm.io/gorm

# 安装 MySQL 驱动
go get -u gorm.io/driver/mysql
```
##### ⚠️ ```gorm.io/driver/mysql``` 是 GORM v2 推荐的 MySQL 驱动，支持 database/sql 接口。  


安装完成后，在项目代码中导入相关包：
```go
import (
    "gorm.io/gorm"
    "gorm.io/driver/mysql"
)
```
---
### 三、连接数据库

GORM 通过 ```gorm.Open()``` 来创建数据库连接。我们需要提供 DSN（Data Source Name） 告诉 GORM 如何连接 MySQL。
```go
package main

import (
  "gorm.io/driver/mysql"
  "gorm.io/gorm"
)

func main() {
  // DSN 格式：user:password@tcp(IP:端口)/数据库名?参数
  dsn := "root:123456@tcp(127.0.0.1:3306)/testdb?charset=utf8mb4&parseTime=True&loc=Local"
  
  // 打开数据库连接
  db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
  if err != nil {
    panic("failed to connect database")
  }

  // 配置连接池
  sqlDB, _ := db.DB()
  sqlDB.SetMaxOpenConns(100) // 最大打开连接数
  sqlDB.SetMaxIdleConns(20)  // 最大空闲连接数
  sqlDB.SetConnMaxLifetime(time.Hour) // 连接最大存活时间
}
```
---

### 四、模型定义（Model） 
在 GORM 中，模型就是一个 Go 结构体，每个字段对应数据库表的一列。
```go
type User struct {
  gorm.Model           // 内置字段：ID, CreatedAt, UpdatedAt, DeletedAt
  Name       string
  Age        int
  Email      string `gorm:"unique"` // Email 唯一
  Password   string
}
```
```gorm.Model``` 是 GORM 提供的基础模型结构体，帮你自动添加：
- ID：主键
- CreatedAt：创建时间
- UpdatedAt：更新时间
- DeletedAt：删除时间（用于软删除）
---
### 五、数据库迁移（Auto Migration）  
GORM 提供 ```AutoMigrate()``` 方法，可以根据模型自动创建或更新数据库表结构。  
```go
// 自动迁移
db.AutoMigrate(&User{})
```
特点：  
- 只会新增字段和索引，不会删除已有字段或索引
- 非常适合在开发阶段快速同步表结构
---
### 六、CRUD 操作   
6.1 创建（Create）
使用 ```db.Create() ```插入一条记录到数据库。
```go
user := User{Name: "Alice", Age: 20, Email: "alice@example.com", Password: "123456"}
result := db.Create(&user)

fmt.Println(user.ID)             // 插入后ID会自动回填
fmt.Println(result.Error)        // 错误信息
fmt.Println(result.RowsAffected) // 影响行数
```
6.2 查询（Read）
GORM 提供了多种查询方法，最常用的是：
- ```First()```：查询第一条记录
- ```Find()```：查询多条记录
- ```Where()```：添加条件
```go
var user User
// 根据主键查询
db.First(&user, 1) // 查询 ID=1 的用户
fmt.Printf("%+v\n", user)

// 条件查询
var users []User
db.Where("age > ?", 18).Find(&users)

// 模糊查询
db.Where("name LIKE ?", "%li%").Find(&users)

// 排序
db.Order("age desc").Find(&users)
```
6.3 更新（Update）
GORM 提供```Update()（单字段```）和```Updates()（多字段）```两种方法。
```go
// 更新单个字段
db.Model(&User{ID: 1}).Update("Age", 21)

// 更新多个字段
db.Model(&User{ID: 1}).Updates(User{Name: "Alice Updated", Age: 22})

// 更新选定字段（忽略零值）
db.Model(&User{ID: 1}).Select("Name").Updates(User{Name: "Alice Selected", Age: 0})
```
6.4 删除（Delete）
默认是软删除（更新 ```DeletedAt``` 字段），不会真正删除数据。
```go
// 软删除
db.Delete(&User{}, 1)

// 物理删除（真正删除数据）
db.Unscoped().Delete(&User{}, 1)
```
---
### 七、事务处理
GORM 支持数据库事务，可以保证一系列操作的原子性。  
```go
tx := db.Begin()
if tx.Error != nil {
  panic(tx.Error)
}

if err := tx.Create(&User{Name: "Bob", Age: 25}).Error; err != nil {
  tx.Rollback()
  panic(err)
}

if err := tx.Create(&User{Name: "Charlie", Age: 30}).Error; err != nil {
  tx.Rollback()
  panic(err)
}

tx.Commit()
```
---
### 八、关联关系
GORM 支持常见的关联关系：
- Has One（一对一）
- Has Many（一对多）
- Belongs To（属于）
- Many To Many（多对多）
一对多示例：
```go
type User struct {
  gorm.Model
  Name  string
  Posts []Post // 一个用户有多篇文章
}

type Post struct {
  gorm.Model
  Title  string
  UserID uint // 外键
}

// 创建用户和文章
db.Create(&User{
  Name: "Alice",
  Posts: []Post{
    {Title: "Post 1"},
    {Title: "Post 2"},
  },
})

// 查询时预加载关联
var user User
db.Preload("Posts").First(&user, 1)
```
---
### 九、钩子函数（Hooks）  
Hooks 是在创建、更新、删除等操作前后自动调用的函数，方便你在数据变更时做额外逻辑（如数据校验、密码加密）。
```go
func (u *User) BeforeCreate(tx *gorm.DB) error {
  fmt.Println("Before Create")
  return nil
}

func (u *User) AfterCreate(tx *gorm.DB) error {
  fmt.Println("After Create")
  return nil
}
```
---
### 十、常见问题与最佳实践
10.1 字段标签（Tags）  
```go
type User struct {
  gorm.Model
  Email string `gorm:"unique;not null"`
  Age   int    `gorm:"default:18"`
}
```
10.2 零值问题  
- 默认 GORM 会忽略零值字段更新
- 解决方法：db.Model(...).Select("字段名").Updates(...)

10.3 软删除  
- 带 gorm.DeletedAt 字段的模型默认启用软删除
- 使用 Unscoped() 查询所有记录（包括已删除的）
  
10.4 性能优化  
- 批量插入：db.CreateInBatches(users, 100)
- 避免 N+1 查询：对于复杂关联查询，预加载（Preload）可以减少 N+1 查询问题，但在数据量较大时要注意性能
  
10.5 批量操作  
- 尽可能使用批量插入和更新，减少数据库连接次数；

### 十一、实战案例
下面是一个简单的示例，展示如何使用 GORM 完成一个用户的 CRUD 操作，并处理一对多关联关系：
```go
package main

import (
    "fmt"
    "log"
    "time"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

type User struct {
    ID        uint      `gorm:"primaryKey"`
    Name      string    `gorm:"size:100;not null"`
    Age       int       `gorm:"not null"`
    Email     string    `gorm:"unique;not null"`
    Orders    []Order   // 一对多关联关系
    CreatedAt time.Time
}

type Order struct {
    ID     uint   `gorm:"primaryKey"`
    Item   string `gorm:"not null"`
    UserID uint
}

func main() {
    dsn := "username:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("连接数据库失败：", err)
    }

    // 自动迁移，确保数据库表结构和模型同步
    db.AutoMigrate(&User{}, &Order{})

    // 创建用户及关联订单
    user := User{
        Name:  "Alice",
        Age:   28,
        Email: "alice@example.com",
        Orders: []Order{
            {Item: "Laptop"},
            {Item: "Smartphone"},
        },
    }
    db.Create(&user)

    // 查询用户及其订单
    var u User
    db.Preload("Orders").First(&u, user.ID)
    fmt.Printf("用户：%v\n订单：%v\n", u, u.Orders)

    // 更新用户数据
    db.Model(&u).Update("Age", 29)

    // 删除用户记录（级联删除订单需要手动处理或设置外键约束）
    db.Delete(&u)
}
```
在上述示例中，我们通过自动迁移确保数据库表结构与模型保持一致，并实现了用户和订单的创建、查询、更新和删除操作。通过 Preload 方法，我们还演示了如何加载关联数据。

---

# 💾 Redis

---
##  💻 项目实战




